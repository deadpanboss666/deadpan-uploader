"""
Uploader per YouTube basato SOLO su OAuth (client_secret.json + token.json).

Viene usato sia in locale che su GitHub Actions.
- In locale, se token.json non esiste, apre il flusso OAuth nel browser.
- Su GitHub Actions, token.json esiste già (lo ricostruiamo dai secret) e il codice
  usa solo il refresh token, senza aprire nessun browser.
"""

from __future__ import annotations

from pathlib import Path
from typing import List, Optional

from subtitles import generate_subtitles_txt_from_text

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow

# Cartella src/
BASE_DIR = Path(__file__).resolve().parent

# File OAuth (quelli che abbiamo anche in Base64 nei secrets GitHub)
CLIENT_SECRET_FILE = BASE_DIR / "client_secret.json"
TOKEN_FILE = BASE_DIR / "token.json"

# Scope necessario per upload su YouTube
SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]


# ---------------------------------------------------------------------------
# AUTENTICAZIONE YOUTUBE (OAUTH)
# ---------------------------------------------------------------------------


def _get_oauth_credentials() -> Credentials:
    """Carica le credenziali OAuth da token.json, eventualmente le refresh-a.

    - In locale, se token.json non esiste, avvia il flusso OAuth nel browser.
    - Su GitHub Actions ci aspettiamo che token.json esista già.
    """
    creds: Optional[Credentials] = None

    if TOKEN_FILE.exists():
        # Carica il token esistente
        creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)

    # Se non sono valide, prova a fare refresh o avvia il flow
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            # Caso GitHub / locale dopo un po' di tempo:
            # usa il refresh token per ottenere un nuovo access token
            creds.refresh(Request())
        else:
            # SOLO uso locale (su GitHub questo non dovrebbe mai servire)
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CLIENT_SECRET_FILE),
                SCOPES,
            )
            creds = flow.run_local_server(port=0)

        # Salva sempre il token aggiornato
        TOKEN_FILE.write_text(creds.to_json(), encoding="utf-8")

    return creds


def _get_youtube_service():
    """Crea il client YouTube autenticato con OAuth."""
    creds = _get_oauth_credentials()
    return build("youtube", "v3", credentials=creds)


# ---------------------------------------------------------------------------
# CHECK FILE VIDEO PRIMA DELL'UPLOAD
# ---------------------------------------------------------------------------


def _check_video_file(video_path: str | Path) -> bool:
    """Controlla che il file video esista e non sia vuoto/corrotto."""
    p = Path(video_path)

    if not p.exists():
        print(f"[Monday] ERRORE: file video non trovato: {p}")
        return False

    size = p.stat().st_size
    print(f"[Monday] Video per upload: {p} (dimensione: {size} byte)")

    # Soglia minima: 1 KB. Se è meno, è quasi sicuramente corrotto.
    if size < 1024:
        print("[Monday] ERRORE: file video troppo piccolo / probabilmente corrotto.")
        return False

    return True


# ---------------------------------------------------------------------------
# UPLOAD VIDEO
# ---------------------------------------------------------------------------


def upload_video(
    video_path: str | Path,
    title: str,
    description: str,
    tags: Optional[List[str]] = None,
    privacy_status: str = "public",
) -> str:
    """Carica un video su YouTube e restituisce l'ID del video.

    Viene chiamata da main.py con:
        upload_video(video_path=final_video, title=title,
                     description=description, tags=tags)
    """
    video_path = Path(video_path)

    # Controllo file prima di tentarne l'upload
    if not _check_video_file(video_path):
        raise RuntimeError("[Monday] Upload annullato: file video non valido.")

    youtube = _get_youtube_service()

    safe_title = (str(title) if title is not None else "").strip() or "Deadpan Auto Test"
    safe_title = safe_title[:95]  # margine sotto ai 100 caratteri

    safe_description = (description or "").strip() or "Autogenerated short by Creator Automatico."

    safe_tags: List[str] = []
    if isinstance(tags, (list, tuple)):
        for t in tags:
            if not t:
                continue
            s = str(t).strip()
            if s:
                safe_tags.append(s[:30])

    print("Titolo che inviamo a YouTube:", repr(safe_title))

    body = {
        "snippet": {
            "title": safe_title,
            "description": safe_description,
            "tags": safe_tags,
            "categoryId": "27",  # Education / documentary-style
        },
        "status": {
            "privacyStatus": privacy_status,
        },
    }

    media = MediaFileUpload(
        str(video_path),
        chunksize=-1,
        resumable=False,
    )

    try:
        print("Inizio upload...")
        request = youtube.videos().insert(
            part="snippet,status",
            body=body,
            media_body=media,
        )
        response = request.execute()
        video_id = response["id"]
        print(f"✅ Upload completato. ID video: {video_id}")
        return video_id
    except HttpError as e:
        msg = str(e)
        print(f"❌ Errore durante l'upload: {msg}")

        # Caso specifico: limite di upload giornaliero raggiunto
        if "uploadLimitExceeded" in msg:
            print(
                "[YouTube] Limite di upload raggiunto per questo account. "
                "La pipeline è ok, ma YouTube al momento non accetta nuovi video."
            )
            return ""  # non facciamo fallire il job

        # Altri errori: li rilanciamo
        raise


# ---------------------------------------------------------------------------
# GENERAZIONE TESTO (SCRIPT) DEADPAN FILES
# ---------------------------------------------------------------------------


def generate_script():
    """
    Genera una micro-storia in stile horror / true crime per Deadpan Files
    e restituisce:
      - script completo (per voce + sottotitoli)
      - title (ottimizzato per CTR)
      - description (2–3 righe con hook)
      - tags (lista di keyword)
    """
    import random

    openings = [
        "Case file 07-19 was never meant to be opened again.",
        "On paper, the disappearance looked simple. Until we heard the recording.",
        "The police closed the case in three days. The family never slept again.",
        "Officially, the building has been empty since 1998. The camera says otherwise.",
        "They called it an urban legend, until the hospital security footage leaked.",
    ]

    mid_parts = [
        "The victim’s phone kept calling the same number, twelve hours after the time of death.",
        "Every witness described the same face, but that person died in another country years earlier.",
        "The tape we received had twenty minutes of silence, except for one whispered word repeated at the end.",
        "The crime scene photos show a shadow that doesn’t match any object in the room.",
        "Neighbors reported screams, but the audio file we have has no voices — just someone breathing behind the microphone.",
    ]

    twists = [
        "The last frame of evidence shows the victim looking directly into the camera… filmed from behind their own back.",
        "When we enhanced the audio, the whisper wasn’t a word. It was a date — tomorrow.",
        "The phone company confirmed the calls came from a number that was disconnected years before the murder.",
        "When the family moved out, the new owners started receiving letters addressed to the missing person, postmarked that same week.",
        "The officer who archived the case requested a transfer the next morning and never spoke about it again.",
    ]

    opening = random.choice(openings)
    mid = random.choice(mid_parts)
    twist = random.choice(twists)

    # Testo che usiamo per voce + sottotitoli
    script = (
        f"{opening} "
        f"{mid} "
        f"{twist} "
        "If you want more cases like this, follow Deadpan Files and check the next file in the stack."
    )

    # Titoli pensati per colpire al volo nello scroll
    possible_titles = [
        "The Case File They Tried To Bury",
        "The Disappearance That Never Made Sense",
        "The Security Footage No One Was Meant To See",
        "The Phone Call From A Dead Number",
        "The Recording That Closed The Station Early",
    ]
    title = random.choice(possible_titles)

    # Descrizione: prima riga = hook, poi contesto e CTA
    description = (
        f"{opening} {mid} {twist}\n\n"
        "Short true crime / horror-style case from Deadpan Files. "
        "Subscribe for more strange case files, found footage and unexplained stories."
    )

    tags = [
        "deadpan files",
        "true crime",
        "horror story",
        "creepy cases",
        "mystery",
        "shorts",
    ]

    return script, title, description, tags


# ---------------------------------------------------------------------------
# SINTESI VOCALE (gTTS -> WAV 48 kHz MONO, CON CHUNK)
# ---------------------------------------------------------------------------


def synth_voice(text, output_path):
    """
    Genera una traccia audio parlata in inglese usando gTTS.

    Per ridurre gli errori dell'API gTTS:
    - spezza il testo in chunk più piccoli
    - genera un MP3 per ogni chunk
    - concatena tutti gli MP3 con ffmpeg
    - converte l'MP3 finale in WAV 48 kHz mono

    Inoltre genera il file subtitles.txt usato dal modulo subtitles.py.
    """
    from pathlib import Path as _Path
    from gtts import gTTS
    import subprocess as _subprocess
    import textwrap as _textwrap

    # 1) Pulizia testo
    text = (text or "").strip()
    if not text:
        raise ValueError("Testo vuoto passato a synth_voice")

    output_path = _Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # 2) Genera subito il file dei sottotitoli (testo completo)
    subtitles_txt_path = _Path("videos_to_upload") / "subtitles.txt"
    subtitles_txt_path.parent.mkdir(parents=True, exist_ok=True)
    generate_subtitles_txt_from_text(
        raw_text=text,
        subtitles_txt_path=subtitles_txt_path,
    )

    # 3) Spezza il testo in frasi
    temp = text.replace("?", "?.").replace("!", "!.")
    sentences = [s.strip() for s in temp.split(".") if s.strip()]
    if not sentences:
        sentences = [text]

    # 4) Raggruppa in chunk di max ~180 caratteri
    max_chars = 180
    chunks: list[str] = []
    current = ""

    for s in sentences:
        if len(current) + len(s) + 1 <= max_chars:
            if current:
                current += " " + s
            else:
                current = s
        else:
            if current:
                chunks.append(current)
            if len(s) > max_chars:
                parts = _textwrap.wrap(s, max_chars)
                chunks.extend(parts)
                current = ""
            else:
                current = s

    if current:
        chunks.append(current)

    if not chunks:
        chunks = [text]

    print(f"[Monday/voice] Numero chunk TTS: {len(chunks)}")

    # 5) Genera un MP3 per ogni chunk
    tmp_dir = output_path.parent
    part_paths: list[_Path] = []

    for idx, chunk in enumerate(chunks, start=1):
        part_mp3 = tmp_dir / f"voice_part_{idx:02d}.mp3"
        print(f"[Monday/voice] Genero chunk {idx}/{len(chunks)} (len={len(chunk)})...")
        try:
            tts = gTTS(text=chunk, lang="en", slow=False)
            tts.save(str(part_mp3))
        except Exception as e:  # noqa: BLE001
            print(f"[Monday/voice] Errore gTTS sul chunk {idx}: {e}")
            raise
        part_paths.append(part_mp3)

    # 6) Concatena tutti gli MP3 in un unico MP3
    concat_list = tmp_dir / "voice_concat.txt"
    concat_list.write_text(
        "".join(f"file '{p.as_posix()}'\n" for p in part_paths),
        encoding="utf-8",
    )

    tmp_mp3 = output_path.with_suffix(".mp3")

    cmd_concat = [
        "ffmpeg",
        "-y",
        "-f",
        "concat",
        "-safe",
        "0",
        "-i",
        str(concat_list),
        "-c",
        "copy",
        str(tmp_mp3),
    ]
    print("[Monday/voice] Concateno i chunk audio con ffmpeg...")
    _subprocess.run(cmd_concat, check=True)

    # 7) Converte l'MP3 finale in WAV 48 kHz mono
    cmd_wav = [
        "ffmpeg",
        "-y",
        "-i",
        str(tmp_mp3),
        "-ac",
        "1",       # mono
        "-ar",
        "48000",   # 48 kHz
        str(output_path),
    ]
    print("[Monday/voice] Converto l'audio in WAV 48 kHz mono...")
    _subprocess.run(cmd_wav, check=True)

    # 8) Pulizia file temporanei
    for p in part_paths:
        try:
            p.unlink()
        except FileNotFoundError:
            pass

    try:
        concat_list.unlink()
    except FileNotFoundError:
        pass

    try:
        tmp_mp3.unlink()
    except FileNotFoundError:
        pass

    print(f"[Monday/voice] Audio finale pronto: {output_path}")


# ---------------------------------------------------------------------------
# TEST MANUALE (opzionale)
# ---------------------------------------------------------------------------


if __name__ == "__main__":
    dummy_path = BASE_DIR / "video.mp4"
    if dummy_path.exists():
        upload_video(
            video_path=dummy_path,
            title="Test upload YouTube (OAuth only)",
            description="Upload di test eseguito da uploader.py",
            tags=["test", "automation"],
            privacy_status="unlisted",
        )
    else:
        print(f"Nessun file di test trovato: {dummy_path}")
