"""
Uploader per YouTube basato SOLO su OAuth (client_secret.json + token.json).

Viene usato sia in locale che su GitHub Actions.
- In locale, se token.json non esiste, apre il flusso OAuth nel browser.
- Su GitHub Actions, token.json esiste già (lo ricostruiamo dai secret) e il codice
  usa solo il refresh token, senza aprire nessun browser.
"""

from __future__ import annotations

from pathlib import Path
from typing import List, Optional

from subtitles import generate_subtitles_txt_from_text

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow

# Cartella src/
BASE_DIR = Path(__file__).resolve().parent
ROOT_DIR = BASE_DIR.parent

# File OAuth (quelli che abbiamo anche in Base64 nei secrets GitHub)
CLIENT_SECRET_FILE = BASE_DIR / "client_secret.json"
TOKEN_FILE = BASE_DIR / "token.json"

# Scope necessario per upload su YouTube
SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]


# ---------------------------------------------------------------------------
# AUTENTICAZIONE YOUTUBE (OAUTH)
# ---------------------------------------------------------------------------


def _get_oauth_credentials() -> Credentials:
    """Carica le credenziali OAuth da token.json, eventualmente le refresh-a.

    - In locale, se token.json non esiste, avvia il flusso OAuth nel browser.
    - Su GitHub Actions ci aspettiamo che token.json esista già.
    """
    creds: Optional[Credentials] = None

    if TOKEN_FILE.exists():
        creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CLIENT_SECRET_FILE),
                SCOPES,
            )
            creds = flow.run_local_server(port=0)

        TOKEN_FILE.write_text(creds.to_json(), encoding="utf-8")

    return creds


def _get_youtube_service():
    """Crea il client YouTube autenticato con OAuth."""
    creds = _get_oauth_credentials()
    return build("youtube", "v3", credentials=creds)


# ---------------------------------------------------------------------------
# CHECK FILE VIDEO PRIMA DELL'UPLOAD
# ---------------------------------------------------------------------------


def _check_video_file(video_path: str | Path) -> bool:
    """Controlla che il file video esista e non sia vuoto/corrotto."""
    p = Path(video_path)

    if not p.exists():
        print(f"[Monday] ERRORE: file video non trovato: {p}")
        return False

    size = p.stat().st_size
    print(f"[Monday] Video per upload: {p} (dimensione: {size} byte)")

    if size < 1024:
        print("[Monday] ERRORE: file video troppo piccolo / probabilmente corrotto.")
        return False

    return True


# ---------------------------------------------------------------------------
# UPLOAD VIDEO
# ---------------------------------------------------------------------------


def upload_video(
    video_path: str | Path,
    title: str,
    description: str,
    tags: Optional[List[str]] = None,
    privacy_status: str = "public",
) -> str:
    """Carica un video su YouTube e restituisce l'ID del video."""
    video_path = Path(video_path)

    if not _check_video_file(video_path):
        raise RuntimeError("[Monday] Upload annullato: file video non valido.")

    youtube = _get_youtube_service()

    safe_title = (str(title) if title is not None else "").strip() or "Deadpan Auto Test"
    safe_title = safe_title[:95]

    safe_description = (description or "").strip() or "Autogenerated short by Creator Automatico."

    safe_tags: List[str] = []
    if isinstance(tags, (list, tuple)):
        for t in tags:
            if not t:
                continue
            s = str(t).strip()
            if s:
                safe_tags.append(s[:30])

    print("Titolo che inviamo a YouTube:", repr(safe_title))

    body = {
        "snippet": {
            "title": safe_title,
            "description": safe_description,
            "tags": safe_tags,
            "categoryId": "27",
        },
        "status": {"privacyStatus": privacy_status},
    }

    media = MediaFileUpload(str(video_path), chunksize=-1, resumable=False)

    try:
        print("Inizio upload...")
        request = youtube.videos().insert(
            part="snippet,status",
            body=body,
            media_body=media,
        )
        response = request.execute()
        video_id = response["id"]
        print(f"✅ Upload completato. ID video: {video_id}")
        return video_id
    except HttpError as e:
        msg = str(e)
        print(f"❌ Errore durante l'upload: {msg}")

        if "uploadLimitExceeded" in msg:
            print(
                "[YouTube] Limite di upload raggiunto per questo account. "
                "La pipeline è ok, ma YouTube al momento non accetta nuovi video."
            )
            return ""

        raise


# ---------------------------------------------------------------------------
# GENERAZIONE TESTO (SCRIPT) DEADPAN FILES — VERSIONE ANTI-RIPETIZIONE
# ---------------------------------------------------------------------------


def generate_script():
    """
    Genera una micro-storia in stile horror / true crime per Deadpan Files
    e restituisce:
      - script completo (per voce + sottotitoli)
      - title (ottimizzato per CTR)
      - description (2–3 righe con hook)
      - tags (lista di keyword)
    """
    import json
    import os
    import random
    from datetime import datetime, timezone

    build_dir = ROOT_DIR / "build"
    build_dir.mkdir(parents=True, exist_ok=True)
    history_path = build_dir / "history.json"

    def load_history() -> dict:
        if history_path.exists():
            try:
                return json.loads(history_path.read_text(encoding="utf-8"))
            except Exception:
                return {}
        return {}

    def save_history(h: dict) -> None:
        try:
            history_path.write_text(json.dumps(h, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    history = load_history()
    used = history.get("used", {})
    if not isinstance(used, dict):
        used = {}

    def remember(key: str, value: str, keep_last: int = 20) -> None:
        arr = used.get(key, [])
        if not isinstance(arr, list):
            arr = []
        arr.append(value)
        # keep last N
        arr = arr[-keep_last:]
        used[key] = arr

    def recently_used(key: str, value: str) -> bool:
        arr = used.get(key, [])
        if not isinstance(arr, list):
            return False
        return value in arr

    # RNG: seed “forte” (diverso ogni run) + stabile abbastanza
    now = datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S")
    seed_material = f"{now}-{os.getpid()}-{os.urandom(8).hex()}"
    rng = random.Random(seed_material)

    # ----------------------------
    # BANCA VARIANTI (grande)
    # ----------------------------
    themes = [
        "cold_case", "found_footage", "dispatch_log", "missing_person", "evidence_tape",
        "crime_scene_photo", "hospital_cctv", "abandoned_building", "anonymous_tip",
        "phone_records", "archived_memo", "transcript"
    ]

    locations = [
        "a shuttered train station", "a coastal motel", "a basement evidence room",
        "an old hospital wing", "a quiet cul-de-sac", "a rural bus stop",
        "a parking garage level B3", "a paper mill outside town", "a derelict cinema",
        "a storage unit on the edge of the city", "a public library after hours",
        "a forest service road marked as 'closed'"
    ]

    agencies = [
        "Missing Persons Unit", "Records Division", "Evidence Control", "Night Dispatch",
        "Internal Affairs", "County Forensics", "Transit Police", "Hospital Security"
    ]

    objects = [
        "a cassette tape", "a burned CD", "a disposable camera", "a pager",
        "a keycard", "a motel receipt", "a voicemail transcript", "a police radio log",
        "a memory card", "a map with one street circled", "a lab report", "a coroner’s note"
    ]

    hooks = [
        "Case file {code} was sealed for a reason.",
        "They closed the report in {days} days. The evidence didn’t agree.",
        "The call came from a number that hasn’t existed since {year}.",
        "The footage is clean—until the last {seconds} seconds.",
        "We found the item in {place}. It shouldn’t have been there.",
        "The witness statement is short. The silence around it is not.",
        "The family asked for one thing: don’t play the tape.",
        "The report says 'no suspects'. The audio says otherwise.",
        "The time of death is listed as {time}. The camera timestamp disagrees.",
        "The building has been empty since {year}. Someone kept logging in."
    ]

    evidence_lines = [
        "The {obj} was tagged and archived under {agency}. Then it vanished from the shelf.",
        "Every photo from the scene shows the same detail: a shadow where no object exists.",
        "The victim’s phone placed {count} calls after the official time of death.",
        "The tape contains {mins} minutes of silence, except for breathing—right behind the mic.",
        "The lab report lists fingerprints that match no database entry… but match each other perfectly.",
        "Dispatch recorded a voice on the line. No one was speaking.",
        "The door log shows a keycard swipe at {time}. The camera shows nobody entering.",
        "A neighbor reported screams. The audio file contains only footsteps approaching the recorder."
    ]

    escalation_lines = [
        "When we enhanced the audio, the background noise spelled something out—slowly.",
        "The timeline breaks in one place, like a frame was removed by hand.",
        "The same name appears in three unrelated cases, each in a different decade.",
        "The victim’s handwriting shows up on a note written after they disappeared.",
        "The security guard quit the next morning and refused to explain why.",
        "The evidence bag was re-sealed with fresh tape—dated the following week."
    ]

    twists = [
        "The final frame shows the victim staring straight into the lens… filmed from behind their own back.",
        "The whisper wasn’t a word. It was a date—tomorrow.",
        "The calls weren’t coming from the victim. They were coming from the evidence room.",
        "The suspect sketch matched a person who died in another country years earlier.",
        "The tape ends with a click—and a second voice saying, 'We’re not done.'",
        "The report was signed by an officer who never existed on payroll records.",
        "The keycard belongs to a patient who was discharged {years} years ago.",
        "The last line in the transcript isn’t spoken. It’s addressed to us."
    ]

    endings = [
        "The case was archived again. Two weeks later, the same {obj} showed up in a new locker.",
        "They told the family it was over. The family still hears the voicemail every night.",
        "We requested the original footage. What we received was a file created tomorrow.",
        "Officially, nothing happened at {place}. Unofficially, nobody works that shift anymore.",
        "When we tried to log it, the system auto-filled the next case number—before we created it."
    ]

    ctas = [
        "If you want the next file, follow Deadpan Files. We’re opening another box tonight.",
        "Follow Deadpan Files. The next case has a name you’ll recognize.",
        "More case files are waiting. Follow—before they disappear again.",
        "Follow Deadpan Files for more archived horror. Next file drops soon.",
        "If this felt wrong, it’s because it is. Follow Deadpan Files for the next report."
    ]

    # titoli: molti pattern, non 5 sempre uguali
    title_patterns = [
        "The {obj} They Never Logged In",
        "The Case File They Tried To Seal",
        "The Footage That Shouldn’t Exist",
        "A Call From {year}",
        "The Evidence Room Incident",
        "The Transcript With A Missing Line",
        "The Night Dispatch Won’t Mention",
        "The Photo That Doesn’t Match Reality",
        "The Number That Kept Calling Back",
        "The Report Signed By Nobody"
    ]

    # helper: pick evitando ripetizioni recenti
    def pick(key: str, pool: List[str], max_tries: int = 30) -> str:
        choice = rng.choice(pool)
        tries = 0
        while recently_used(key, choice) and tries < max_tries:
            choice = rng.choice(pool)
            tries += 1
        remember(key, choice)
        return choice

    # variabili per riempire template
    code = f"{rng.randint(1, 99):02d}-{rng.randint(1, 28):02d}"
    days = rng.choice([1, 2, 3, 5, 7, 9])
    year = rng.choice([1991, 1994, 1998, 2001, 2006, 2011, 2016])
    seconds = rng.choice([7, 9, 11, 13, 17, 19])
    mins = rng.choice([12, 18, 20, 23, 27])
    place = pick("place", locations)
    agency = pick("agency", agencies)
    obj = pick("obj", objects)
    count = rng.choice([3, 5, 7, 11, 12, 14])
    time = rng.choice(["02:13", "03:07", "01:44", "04:22", "00:58"])
    years = rng.choice([7, 11, 14, 19, 23])

    theme = pick("theme", themes)

    # ----------------------------
    # STRUTTURE DIVERSE (non template unico)
    # ----------------------------
    def render(template: str) -> str:
        return template.format(
            code=code,
            days=days,
            year=year,
            seconds=seconds,
            mins=mins,
            place=place,
            agency=agency,
            obj=obj,
            count=count,
            time=time,
            years=years,
        )

    hook = render(pick("hook", hooks))
    ev1 = render(pick("evidence", evidence_lines))
    esc = render(pick("escalation", escalation_lines))
    tw = render(pick("twist", twists))
    end = render(pick("ending", endings))
    cta = pick("cta", ctas)

    # Template list (scegliamo uno a caso)
    templates = []

    # 1) Case file classico
    templates.append(
        f"{hook} {ev1} {esc} {tw} {end} {cta}"
    )

    # 2) Dispatch log
    templates.append(
        f"Night dispatch log, {agency}. "
        f"At {time}, a caller reported activity at {place}. "
        f"{ev1} {esc} {tw} {end} {cta}"
    )

    # 3) Found footage note
    templates.append(
        f"We recovered {obj} from {place}. "
        f"{hook} {ev1} "
        f"The footage stays normal—until the last {seconds} seconds. "
        f"{tw} {end} {cta}"
    )

    # 4) Transcript
    templates.append(
        f"Transcript excerpt—case {code}. "
        f"{hook} {ev1} "
        f"Then the recording changes. "
        f"{esc} {tw} {end} {cta}"
    )

    # 5) Archived memo
    templates.append(
        f"Archived memo from {agency}. "
        f"{hook} "
        f"Subject: {place}. "
        f"{ev1} {esc} {tw} {end} {cta}"
    )

    script = rng.choice(templates)

    # Pulizia per TTS + subtitles: frasi più corte e ritmo migliore
    # (aggiunge micro-pause, senza esagerare)
    script = script.replace("—", ". ").replace("…", "...").strip()

    # Titolo: pattern + variabili, anti-ripetizione
    title = render(pick("title", title_patterns))
    # Evita titoli troppo lunghi
    title = title.strip()
    if len(title) > 88:
        title = title[:88].rstrip()

    # Descrizione: hook + contesto + CTA breve (variabile)
    desc_lines = [
        hook,
        render(ev1),
        render(tw),
        "",
        "Deadpan Files — short true crime / horror case file.",
        "New file drops automatically. Follow for the next report."
    ]
    description = "\n".join(desc_lines)

    # Tags: aggiungiamo variabilità senza roba “rischiosa”
    base_tags = [
        "deadpan files",
        "true crime",
        "horror story",
        "creepy cases",
        "mystery",
        "shorts",
        "case file",
        "found footage",
        "unexplained",
    ]
    theme_tags = {
        "cold_case": ["cold case", "unsolved"],
        "found_footage": ["found footage", "cctv"],
        "dispatch_log": ["police dispatch", "radio log"],
        "missing_person": ["missing person", "disappearance"],
        "evidence_tape": ["evidence tape", "audio recording"],
        "crime_scene_photo": ["crime scene", "evidence"],
        "hospital_cctv": ["hospital", "security footage"],
        "abandoned_building": ["abandoned", "urban exploration"],
        "anonymous_tip": ["anonymous tip", "investigation"],
        "phone_records": ["phone call", "voicemail"],
        "archived_memo": ["archived", "classified"],
        "transcript": ["transcript", "interview"],
    }

    tags = list(dict.fromkeys(base_tags + theme_tags.get(theme, [])))  # unique preserve order
    tags = tags[:20]

    # salva history
    history["used"] = used
    save_history(history)

    return script, title, description, tags


# ---------------------------------------------------------------------------
# SINTESI VOCALE (legacy: gTTS -> WAV 48 kHz MONO, CON CHUNK)
# NOTA: la pipeline nuova usa tts_timestamps.py, ma lasciamo questa funzione
# per compatibilità e test locali.
# ---------------------------------------------------------------------------


def synth_voice(text, output_path):
    """
    Genera una traccia audio parlata in inglese usando gTTS.

    Per ridurre gli errori dell'API gTTS:
    - spezza il testo in chunk più piccoli
    - genera un MP3 per ogni chunk
    - concatena tutti gli MP3 con ffmpeg
    - converte l'MP3 finale in WAV 48 kHz mono

    Inoltre genera il file subtitles.txt usato dal modulo subtitles.py (legacy).
    """
    from pathlib import Path as _Path
    from gtts import gTTS
    import subprocess as _subprocess
    import textwrap as _textwrap

    text = (text or "").strip()
    if not text:
        raise ValueError("Testo vuoto passato a synth_voice")

    output_path = _Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    subtitles_txt_path = _Path("videos_to_upload") / "subtitles.txt"
    subtitles_txt_path.parent.mkdir(parents=True, exist_ok=True)
    generate_subtitles_txt_from_text(raw_text=text, subtitles_txt_path=subtitles_txt_path)

    temp = text.replace("?", "?.").replace("!", "!.")
    sentences = [s.strip() for s in temp.split(".") if s.strip()]
    if not sentences:
        sentences = [text]

    max_chars = 180
    chunks: list[str] = []
    current = ""

    for s in sentences:
        if len(current) + len(s) + 1 <= max_chars:
            current = f"{current} {s}".strip() if current else s
        else:
            if current:
                chunks.append(current)
            if len(s) > max_chars:
                parts = _textwrap.wrap(s, max_chars)
                chunks.extend(parts)
                current = ""
            else:
                current = s

    if current:
        chunks.append(current)

    if not chunks:
        chunks = [text]

    print(f"[Monday/voice] Numero chunk TTS: {len(chunks)}")

    tmp_dir = output_path.parent
    part_paths: list[_Path] = []

    for idx, chunk in enumerate(chunks, start=1):
        part_mp3 = tmp_dir / f"voice_part_{idx:02d}.mp3"
        print(f"[Monday/voice] Genero chunk {idx}/{len(chunks)} (len={len(chunk)})...")
        tts = gTTS(text=chunk, lang="en", slow=False)
        tts.save(str(part_mp3))
        part_paths.append(part_mp3)

    concat_list = tmp_dir / "voice_concat.txt"
    concat_list.write_text("".join(f"file '{p.as_posix()}'\n" for p in part_paths), encoding="utf-8")

    tmp_mp3 = output_path.with_suffix(".mp3")

    cmd_concat = [
        "ffmpeg",
        "-y",
        "-f",
        "concat",
        "-safe",
        "0",
        "-i",
        str(concat_list),
        "-c",
        "copy",
        str(tmp_mp3),
    ]
    print("[Monday/voice] Concateno i chunk audio con ffmpeg...")
    _subprocess.run(cmd_concat, check=True)

    cmd_wav = [
        "ffmpeg",
        "-y",
        "-i",
        str(tmp_mp3),
        "-ac",
        "1",
        "-ar",
        "48000",
        str(output_path),
    ]
    print("[Monday/voice] Converto l'audio in WAV 48 kHz mono...")
    _subprocess.run(cmd_wav, check=True)

    for p in part_paths:
        try:
            p.unlink()
        except FileNotFoundError:
            pass

    try:
        concat_list.unlink()
    except FileNotFoundError:
        pass

    try:
        tmp_mp3.unlink()
    except FileNotFoundError:
        pass

    print(f"[Monday/voice] Audio finale pronto: {output_path}")


# ---------------------------------------------------------------------------
# TEST MANUALE (opzionale)
# ---------------------------------------------------------------------------


if __name__ == "__main__":
    dummy_path = BASE_DIR / "video.mp4"
    if dummy_path.exists():
        upload_video(
            video_path=dummy_path,
            title="Test upload YouTube (OAuth only)",
            description="Upload di test eseguito da uploader.py",
            tags=["test", "automation"],
            privacy_status="unlisted",
        )
    else:
        print(f"Nessun file di test trovato: {dummy_path}")
