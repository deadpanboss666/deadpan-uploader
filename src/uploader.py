"""
Uploader per YouTube basato SOLO su OAuth (client_secret.json + token.json).

Viene usato sia in locale che su GitHub Actions.
- In locale, se token.json non esiste, apre il flusso OAuth nel browser.
- Su GitHub Actions, token.json esiste già (lo ricostruiamo dai secret) e il codice
  usa solo il refresh token, senza aprire nessun browser.
"""

from __future__ import annotations

from pathlib import Path
from typing import List, Optional

from subtitles import generate_subtitles_txt_from_text

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow

# Cartella src/
BASE_DIR = Path(__file__).resolve().parent

# File OAuth (quelli che abbiamo anche in Base64 nei secrets GitHub)
CLIENT_SECRET_FILE = BASE_DIR / "client_secret.json"
TOKEN_FILE = BASE_DIR / "token.json"

# Scope necessario per upload su YouTube
SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]


# ---------------------------------------------------------------------------
# AUTENTICAZIONE YOUTUBE (OAUTH)
# ---------------------------------------------------------------------------


def _get_oauth_credentials() -> Credentials:
    """Carica le credenziali OAuth da token.json, eventualmente le refresh-a.

    - In locale, se token.json non esiste, avvia il flusso OAuth nel browser.
    - Su GitHub Actions ci aspettiamo che token.json esista già.
    """
    creds: Optional[Credentials] = None

    if TOKEN_FILE.exists():
        # Carica il token esistente
        creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)

    # Se non sono valide, prova a fare refresh o avvia il flow
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            # Caso GitHub / locale dopo un po' di tempo:
            # usa il refresh token per ottenere un nuovo access token
            creds.refresh(Request())
        else:
            # SOLO uso locale (su GitHub questo non dovrebbe mai servire)
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CLIENT_SECRET_FILE),
                SCOPES,
            )
            creds = flow.run_local_server(port=0)

        # Salva sempre il token aggiornato
        TOKEN_FILE.write_text(creds.to_json(), encoding="utf-8")

    return creds


def _get_youtube_service():
    """Crea il client YouTube autenticato con OAuth."""
    creds = _get_oauth_credentials()
    return build("youtube", "v3", credentials=creds)


# ---------------------------------------------------------------------------
# CHECK FILE VIDEO PRIMA DELL'UPLOAD
# ---------------------------------------------------------------------------


def _check_video_file(video_path: str | Path) -> bool:
    """Controlla che il file video esista e non sia vuoto/corrotto."""
    p = Path(video_path)

    if not p.exists():
        print(f"[Monday] ERRORE: file video non trovato: {p}")
        return False

    size = p.stat().st_size
    print(f"[Monday] Video per upload: {p} (dimensione: {size} byte)")

    # Soglia minima: 1 KB. Se è meno, è quasi sicuramente corrotto.
    if size < 1024:
        print("[Monday] ERRORE: file video troppo piccolo / probabilmente corrotto.")
        return False

    return True


# ---------------------------------------------------------------------------
# UPLOAD VIDEO
# ---------------------------------------------------------------------------


def upload_video(
    video_path: str | Path,
    title: str,
    description: str,
    tags: Optional[List[str]] = None,
    privacy_status: str = "public",
) -> str:
    """Carica un video su YouTube e restituisce l'ID del video.

    Viene chiamata da main.py con:
        upload_video(video_path=final_video, title=seo.title,
                     description=seo.description, tags=seo.tags)
    """
    video_path = Path(video_path)

    # Controllo file prima di tentarne l'upload
    if not _check_video_file(video_path):
        raise RuntimeError("[Monday] Upload annullato: file video non valido.")

    youtube = _get_youtube_service()

    safe_title = (str(title) if title is not None else "").strip() or "Deadpan Auto Test"
    safe_title = safe_title[:95]  # margine sotto ai 100 caratteri

    safe_description = (description or "").strip() or "Autogenerated short by Creator Automatico."

    safe_tags: List[str] = []
    if isinstance(tags, (list, tuple)):
        for t in tags:
            if not t:
                continue
            s = str(t).strip()
            if s:
                safe_tags.append(s[:30])

    print("Titolo che inviamo a YouTube:", repr(safe_title))

    body = {
        "snippet": {
            "title": safe_title,
            "description": safe_description,
            "tags": safe_tags,
            "categoryId": "27",  # Education / documentary-style
        },
        "status": {
            "privacyStatus": privacy_status,
        },
    }

    media = MediaFileUpload(
        str(video_path),
        chunksize=-1,
        resumable=False,
    )

    try:
        print("Inizio upload...")
        request = youtube.videos().insert(
            part="snippet,status",
            body=body,
            media_body=media,
        )
        response = request.execute()
        video_id = response["id"]
        print(f"✅ Upload completato. ID video: {video_id}")
        return video_id
    except HttpError as e:
        msg = str(e)
        print(f"❌ Errore durante l'upload: {msg}")

        # Caso specifico: limite di upload giornaliero raggiunto
        if "uploadLimitExceeded" in msg:
            print(
                "[YouTube] Limite di upload raggiunto per questo account. "
                "La pipeline è ok, ma YouTube al momento non accetta nuovi video."
            )
            return ""  # non facciamo fallire il job

        # Altri errori: li rilanciamo
        raise


# ---------------------------------------------------------------------------
# GENERAZIONE TESTO (SCRIPT) DEADPAN FILES
# ---------------------------------------------------------------------------


def generate_script():
    """
    Genera una micro-storia in stile horror / true crime per Deadpan Files
    e restituisce:
      - script completo (per voce + sottotitoli)
      - title (ottimizzato per CTR)
      - description (2–3 righe con hook)
      - tags (lista di keyword)
    """
    import random

    openings = [
        "Case file 07-19 was never meant to be opened again.",
        "On paper, the disappearance looked simple. Until we heard the recording.",
        "The police closed the case in three days. The family never slept again.",
        "Officially, the building has been empty since 1998. The camera says otherwise.",
        "They called it an urban legend, until the hospital security footage leaked.",
    ]

    mid_parts = [
        "The victim’s phone kept calling the same number, twelve hours after the time of death.",
        "Every witness described the same face, but that person died in another country years earlier.",
        "The tape we received had twenty minutes of silence, except for one whispered word repeated at the end.",
        "The crime scene photos show a shadow that doesn’t match any object in the room.",
        "Neighbors reported screams, but the audio file we have has no voices — just someone breathing behind the microphone.",
    ]

    twists = [
        "The last frame of evidence shows the victim looking directly into the camera… filmed from behind their own back.",
        "When we enhanced the audio, the whisper wasn’t a word. It was a date — tomorrow.",
        "The phone company confirmed the calls came from a number that was disconnected years before the murder.",
        "When the family moved out, the new owners started receiving letters addressed to the missing person, postmarked that same week.",
        "The officer who archived the case requested a transfer the next morning and never spoke about it again.",
    ]

    opening = random.choice(openings)
    mid = random.choice(mid_parts)
    twist = random.choice(twists)

    # Testo che usiamo per voce + sottotitoli
    script = (
        f"{opening} "
        f"{mid} "
        f"{twist} "
        "If you want more cases like this, follow Deadpan Files and check the next file in the stack."
    )

    # Titoli pensati per colpire al volo nello scroll
    possible_titles = [
        "The Case File They Tried To Bury",
        "The Disappearance That Never Made Sense",
        "The Security Footage No One Was Meant To See",
        "The Phone Call From A Dead Number",
        "The Recording That Closed The Station Early",
    ]
    title = random.choice(possible_titles)

    # Descrizione: prima riga = hook, poi contesto e CTA
    description = (
        f"{opening} {mid} {twist}\n\n"
        "Short true crime / horror-style case from Deadpan Files. "
        "Subscribe for more strange case files, found footage and unexplained stories."
    )

    tags = [
        "deadpan files",
        "true crime",
        "horror story",
        "creepy cases",
        "mystery",
        "shorts",
    ]

    return script, title, description, tags


# ---------------------------------------------------------------------------
# SINTESI VOCALE (gTTS -> WAV 48 kHz MONO)
# ---------------------------------------------------------------------------


def synth_voice(text, output_path):
    """
    Genera una traccia audio parlata in inglese usando gTTS.
    - text: testo completo dello short
    - output_path: percorso del file WAV finale (48 kHz, mono)
    """
    from pathlib import Path as _Path
    from gtts import gTTS
    import subprocess as _subprocess

    text = (text or "").strip()
    if not text:
        raise ValueError("Testo vuoto passato a synth_voice")

    output_path = _Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # 1) Crea un MP3 temporaneo con gTTS
    tmp_mp3 = output_path.with_suffix(".mp3")

    # Monday: genera automaticamente il file dei sottotitoli
    subtitles_txt_path = _Path("videos_to_upload") / "subtitles.txt"
    generate_subtitles_txt_from_text(
        raw_text=text,
        subtitles_txt_path=subtitles_txt_path,
    )

    # Sintesi vocale
    tts = gTTS(text=text, lang="en", slow=False)
    tts.save(str(tmp_mp3))

    # 2) Converte l'MP3 in WAV 48 kHz mono con ffmpeg
    cmd = [
        "ffmpeg",
        "-y",              # sovrascrivi se esiste
        "-i", str(tmp_mp3),
        "-ac", "1",        # mono
        "-ar", "48000",    # 48 kHz
        str(output_path),
    ]
    print("Eseguo ffmpeg per convertire l'audio TTS...")
    _subprocess.run(cmd, check=True)

    # 3) Rimuovi l'MP3 temporaneo
    try:
        tmp_mp3.unlink()
    except FileNotFoundError:
        pass


# ---------------------------------------------------------------------------
# TEST MANUALE (opzionale)
# ---------------------------------------------------------------------------


if __name__ == "__main__":
    dummy_path = BASE_DIR / "video.mp4"
    if dummy_path.exists():
        upload_video(
            video_path=dummy_path,
            title="Test upload YouTube (OAuth only)",
            description="Upload di test eseguito da uploader.py",
            tags=["test", "automation"],
            privacy_status="unlisted",
        )
    else:
        print(f"Nessun file di test trovato: {dummy_path}")
