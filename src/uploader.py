"""
Uploader per YouTube basato SOLO su OAuth (client_secret.json + token.json).

Viene usato sia in locale che su GitHub Actions.
- In locale, se token.json non esiste, apre il flusso OAuth nel browser.
- Su GitHub Actions, token.json esiste già (lo ricostruiamo dai secret) e il codice
  usa solo il refresh token, senza aprire nessun browser.
"""

from __future__ import annotations

from pathlib import Path
from typing import List, Optional

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow

# Cartella src/
BASE_DIR = Path(__file__).resolve().parent

# File OAuth (quelli che abbiamo anche in Base64 nei secrets GitHub)
CLIENT_SECRET_FILE = BASE_DIR / "client_secret.json"
TOKEN_FILE = BASE_DIR / "token.json"

# Scope necessario per upload su YouTube
SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]


# ---------------------------------------------------------------------------
# AUTENTICAZIONE YOUTUBE (OAUTH)
# ---------------------------------------------------------------------------


def _get_oauth_credentials() -> Credentials:
    """Carica le credenziali OAuth da token.json, eventualmente le refresh-a.

    - In locale, se token.json non esiste, avvia il flusso OAuth nel browser.
    - Su GitHub Actions ci aspettiamo che token.json esista già.
    """
    creds: Optional[Credentials] = None

    if TOKEN_FILE.exists():
        # Carica il token esistente
        creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)

    # Se non sono valide, prova a fare refresh o avvia il flow
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            # Caso GitHub / locale dopo un po' di tempo:
            # usa il refresh token per ottenere un nuovo access token
            creds.refresh(Request())
        else:
            # SOLO uso locale (su GitHub questo non dovrebbe mai servire)
            flow = InstalledAppFlow.from_client_secrets_file(
                str(CLIENT_SECRET_FILE),
                SCOPES,
            )
            creds = flow.run_local_server(port=0)

        # Salva sempre il token aggiornato
        TOKEN_FILE.write_text(creds.to_json(), encoding="utf-8")

    return creds


def _get_youtube_service():
    """Crea il client YouTube autenticato con OAuth."""
    creds = _get_oauth_credentials()
    return build("youtube", "v3", credentials=creds)


# ---------------------------------------------------------------------------
# UPLOAD VIDEO
# ---------------------------------------------------------------------------


def upload_video(
    video_path: str | Path,
    title: str,
    description: str,
    tags: Optional[List[str]] = None,
    privacy_status: str = "public",
) -> str:
    """Carica un video su YouTube e restituisce l'ID del video.

    Viene chiamata da main.py con:
        upload_video(video_path=final_video, title=seo.title,
                     description=seo.description, tags=seo.tags)
    """
    video_path = str(Path(video_path))

    youtube = _get_youtube_service()

    safe_title = (str(title) if title is not None else "").strip() or "Deadpan Auto Test"
    safe_title = safe_title[:95]  # margine sotto ai 100 caratteri

    safe_description = (description or "").strip() or "Autogenerated short by Creator Automatico."

    safe_tags: List[str] = []
    if isinstance(tags, (list, tuple)):
        for t in tags:
            if not t:
                continue
            s = str(t).strip()
            if s:
                safe_tags.append(s[:30])

    print("Titolo che inviamo a YouTube:", repr(safe_title))

    body = {
        "snippet": {
            "title": safe_title,
            "description": safe_description,
            "tags": safe_tags,
            "categoryId": "27",  # Education / documentary-style
        },
        "status": {
            "privacyStatus": privacy_status,
        },
    }

    try:
        print("Inizio upload su YouTube...")
        request = youtube.videos().insert(
            part="snippet,status",
            body=body,
            media_body=video_path,
        )
        response = request.execute()
        video_id = response["id"]
        print(f"✅ Upload completato. ID video: {video_id}")
        return video_id
    except HttpError as e:
        print(f"❌ Errore durante l'upload: {e}")
        raise


# ---------------------------------------------------------------------------
# GENERAZIONE TESTO (SCRIPT) DEADPAN FILES
# ---------------------------------------------------------------------------


def generate_script():
    """
    Genera una micro-storia in stile horror / true crime per Deadpan Files.
    Ritorna (script, topic) per lo Short.
    """
    import random

    openings = [
        "Case file 07-19 was never meant to be opened again.",
        "On paper, the disappearance looked simple. Until we heard the recording.",
        "The police closed the case in three days. The family never slept again.",
        "Officially, the building has been empty since 1998. The camera says otherwise.",
        "They called it an urban legend, until the hospital security footage leaked.",
    ]

    mid_parts = [
        "The victim’s phone kept calling the same number, twelve hours after the time of death.",
        "Every witness described the same face, but that person died in another country years earlier.",
        "The tape we received had twenty minutes of silence, except for one whispered word repeated at the end.",
        "The crime scene photos show a shadow that doesn’t match any object in the room.",
        "Neighbors reported screams, but the audio file we have has no voices — just someone breathing behind the microphone.",
    ]

    twists = [
        "The last frame of evidence shows the victim looking directly into the camera… filmed from behind their own back.",
        "When we enhanced the audio, the whisper wasn’t a word. It was a date — tomorrow.",
        "The phone company confirmed the calls came from a number that was disconnected years before the murder.",
        "When the family moved out, the new owners started receiving letters addressed to the missing person, postmarked that same week.",
        "The officer who archived the case requested a transfer the next morning and never spoke about it again.",
    ]

    opening = random.choice(openings)
    mid = random.choice(mid_parts)
    twist = random.choice(twists)

    script = (
        f"{opening} "
        f"{mid} "
        f"{twist} "
        "If you want more cases like this, follow Deadpan Files and check the next file in the stack."
    )

    topic = "Deadpan Files case story"
    return script, topic


# ---------------------------------------------------------------------------
# SINTESI VOCALE (gTTS -> WAV 48 kHz MONO)
# ---------------------------------------------------------------------------


def synth_voice(text, output_path):
    """
    Genera una traccia audio parlata in inglese usando gTTS.
    - text: testo completo dello short
    - output_path: percorso del file WAV finale (48 kHz, mono)
    """
    from pathlib import Path
    from gtts import gTTS
    import subprocess

    text = (text or "").strip()
    if not text:
        raise ValueError("Testo vuoto passato a synth_voice")

    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # 1) Crea un MP3 temporaneo con gTTS
    tmp_mp3 = output_path.with_suffix(".mp3")

    tts = gTTS(text=text, lang="en", slow=False)
    tts.save(str(tmp_mp3))

    # 2) Converte l'MP3 in WAV 48 kHz mono con ffmpeg
    cmd = [
        "ffmpeg",
        "-y",              # sovrascrivi se esiste
        "-i", str(tmp_mp3),
        "-ac", "1",        # mono
        "-ar", "48000",    # 48 kHz
        str(output_path),
    ]
    print("Eseguo ffmpeg per convertire l'audio TTS...")
    subprocess.run(cmd, check=True)

    # 3) Rimuovi l'MP3 temporaneo
    try:
        tmp_mp3.unlink()
    except FileNotFoundError:
        pass


# ---------------------------------------------------------------------------
# TEST MANUALE (opzionale)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    dummy_path = BASE_DIR / "video.mp4"
    if dummy_path.exists():
        upload_video(
            video_path=dummy_path,
            title="Test upload YouTube (OAuth only)",
            description="Upload di test eseguito da uploader.py",
            tags=["test", "automation"],
            privacy_status="unlisted",
        )
    else:
        print(f"Nessun file di test trovato: {dummy_path}")
